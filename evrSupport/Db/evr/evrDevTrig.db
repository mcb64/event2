#
# evrDevTrig.db
#
# Need one instance for each trigger output you're controlling
# For PMC 230 EVR's w/ no transition board, there are just the
# three on the front panel.
# For VME 230 EVR's w/ no transition board, there are eight
# For EVR's w/ a transition board, up to 16 more triggers are available
#
# Required macros:
#	EVR  - EVR PV prefix
#	TRIG - Trigger PV prefix
#	TYPE - DG or OT (Extended Delay Pulse Generator or OTP Pulse Generator)
#	TYPENUM - 0 or 1, corresponds to TYPE - DG or OT respectively.  Used for DOL field.
#	N	 - Trigger number (0, 1, 2, ...)
#	TCTL - Trigger control (enable) field, one of DG0E, DG1E, DG2E, OTP0, ..., OTPD

# Optional macros:
#	DESC - Trigger description
#	DES	 - Trigger TDES, desired delay value, default 0
#	WID	 - Initial Trigger width, default 100ns
#	POL	 - Initial Trigger polarity, default 0 (NORMAL)
#	CTL	 - Initial Trigger enable, default 1 (Enabled)
#	ACTV - Invariant Trigger Activate, default 1
#	DRVH - High limit of desired delay, default  2.14748E09
#	DRVL - Low  limit of desired delay, default -2.14748E09
#

#
# Primary trigger controls are:
# $(TRIG):TEC	- Trigger event code
# $(TRIG):TCTL	- Trigger output enable/disable
# $(TRIG):TPOL	- Trigger output polarity
# $(TRIG):TWID	- Trigger width in ns
# $(TRIG):TDES	- Trigger desired delay in ns
#

# New record to support the concept and U/I for Locking the trigger timing
# This version is purely a visual indicator.
# Subsequent versions will likely provide some level of db protection as well.
record( bo, "$(TRIG):LOCKED" )
{
	field( ZNAM, "Unlocked" )
	field( ONAM, "Locked" )
	info( autosaveFields, "DESC VAL" )
}

# Trigger type, set in substitution file
record( bo, "$(TRIG):TYPE" )
{
	field( DOL,  "$(TYPENUM)" )
	field( OMSL, "closed_loop" )
	field( ZNAM, "DG" )
	field( ONAM, "OT" )
	field( PINI, "YES" )
	info( autosaveFields, "DESC" )
}

# True for 1 sec after startup
# Used to disable invariant timing during startup
record( bo, "$(TRIG):STARTING_UP" )
{
	field( DOL,	 "1" )
	field( ZNAM, "Normal" )
	field( ONAM, "StartingUp" )
	field( HIGH, "3.0" )
	field( PINI, "YES" )
}

# This record monitors the ASUB_INVARIANT inputs and
# uses FLNK to force processing of ASUB_INVARIANT
# which must use NPP or PP input links to ensure that
# all the input values are current.
record( calc, "$(TRIG):INVARIANT_UPDATE" )
{
	field( INPA, "$(TRIG):TDES.VAL CPP NMS" )
	field( INPB, "$(EVR):CTRL.$(TYPE)$(N)D CPP NMS" )
	field( INPC, "$(EVR):CTRL.$(TYPE)$(N)C CPP NMS" )
	field( INPD, "$(TRIG):LSUB_EVSEL.VAL CPP NMS" )
	field( INPE, "$(TRIG):INVARIANT_UPDATE.LA NPP NMS" )
	field( INPF, "$(TRIG):INVARIANT_UPDATE.LB NPP NMS" )
	field( INPG, "$(TRIG):INVARIANT_UPDATE.LC NPP NMS" )
	field( INPH, "$(TRIG):INVARIANT_UPDATE.LD NPP NMS" )
	field( CALC, "A!=E||B!=F||C!=G||D!=H" )
	field( FLNK, "$(TRIG):ASUB_INVARIANT" )
}

# This aSub record replaces prior FLNK and CPP based logic for
# propagating changes for invariant timing.
# When invariant timing is enabled, changes to event code
# preserve TDES and update tick delay.
# When invariant timing is disabled, changes to event code
# change TDES.
# I/O Parameters
#	INPA,OUTA:	Desired trigger delay (TDES)
#	INPB,OUTB:	Trigger delay in ticks ($EVR:CTRL.DG*D)
#	INPC,OUTC:	Trigger scale factor ($EVR:CTRL.DG*C)
#	INPD,OUTD:	User specified trigger event code via LSUB_EVSEL (TEC)
#	INPE,OUTE:	Current trigger event code offset in ticks (TOFFSET)
#	INPF,OUTF:	DEV trigger event code, normally empty string, overridden by camera IOC
#	INPG,OUTG:	DEV trigger delay,      normally empty string, overridden by camera IOC
# Input only Parameters
#	INPM:	0 (disable) or 1 (enable) invariant timing
#	INPN:	Currently selected trigger event code from EVENT*CTRL records (EC_RBV)
#	INPO:	Trigger reference time (TREF)
#	INPQ:	Startup Flag, 1 or 2 sec after iocInit(), disable invariant timing while true
#
# NOTE: Output links always get written!
# If needed, write to calcout records w/ OOPT="On Change" to reduce propagation.
# or ...
# Don't use output links.
# Just update the VALA, VALB, ... fields and use records w/ DOL CPP links to propagate.
#
# Possible additional params:
#	INP?:	User friendly trigger delay string, both input and output (USER_DELAY)
#   INP?:	Enable auto USER_EGU updates
#	INP?:	USER_EGU, both input and output
#	OUT?:	Trigger event code (EVENTCTRL.ENM)
#	OUT?:	Trigger delay string, both input and output (USER_DELAY)
#	OUT?:	USER_EGU, both input and output
# TODO: Add trigger width PVs?
# Most of the following will just be updated each time using normal link logic
#	OUT?:	BW_TDES
#	OUT?:	BW_TDLY
#	OUT?:	BW_TDLY_NS
#	OUT?:	EC_RBV
#	OUT?:	TDLY
#	OUT?:	TDLY_NS
#	OUT?:	TOFFSET_NS
record( aSub, "$(TRIG):ASUB_INVARIANT" )
{
	field( TPRO, "$(TPRO=0)" )
	field( DESC, "Invariant timing logic" )
	field( INAM, "aSubEvrDevTrigInit" )
	field( SNAM, "aSubEvrDevTrig" )
	field( FTA,  "DOUBLE" )	field( INPA, "$(TRIG):TDES.VAL NPP MS" )
	field( FTVA, "DOUBLE" )
	field( FTB,  "ULONG" )	field( INPB, "$(EVR):CTRL.$(TYPE)$(N)D NPP MS" )
	field( FTVB, "ULONG" )
	field( FTC,  "ULONG" )	field( INPC, "$(EVR):CTRL.$(TYPE)$(N)C NPP MS" )
	field( FTVC, "ULONG" )
	field( FTD,  "ULONG" )	field( INPD, "$(TRIG):LSUB_EVSEL.VAL NPP MS" )
	field( FTVD, "ULONG" )
#	field( FTE,  "DOUBLE" )	field( INPE, "$(TRIG):TOFFSET.VAL CPP MS" )
#	field( FTVE, "DOUBLE" )
#	INPE,OUTE:	DEV trigger event code, normally empty string, overridden by camera IOC
#	INPF,OUTF:	DEV trigger delay,      normally empty string, overridden by camera IOC
	field( INPM, "$(ACTV=1)" )							field( FTM,  "LONG" )
#	field( INPN, "$(TRIG):EC_RBV NPP MS" )
	field( FTN,  "LONG" )
	field( INPO, "$(EVR):TREF CPP MS" )					field( FTO,  "DOUBLE" )
	field( INPP, "$(EVR):EC:DELAYS NPP NMS" )			field( FTP, "LONG" )	field( NOP,  "256" )
	field( INPQ, "$(TRIG):STARTING_UP CPP MS" )			field( FTQ,  "LONG" )

# Note: EFLG only affects monitors.  OUT links always get written
	field( EFLG, "ON CHANGE" )
	field( FLNK, "$(TRIG):BW_TDES_CALC" )
}


record( calcout, "$(TRIG):BW_TDES_CALC" )
{
#field( TPRO, "$(TPRO=2)" )
	field( SDIS, "$(TRIG):STARTING_UP" )
	field( INPA, "$(TRIG):ASUB_INVARIANT.VALA NPP NMS" )
	field( CALC, "A" )
	field( OOPT, "On Change" )
	field( EGU,  "ns" )
	field( OUT,  "$(TRIG):TDES.VAL PP NMS" )
	field( FLNK, "$(TRIG):FW_TDLY_CALC" )
}

record( calcout, "$(TRIG):FW_TDLY_CALC" )
{
#field( TPRO, "$(TPRO=2)" )
	field( SDIS, "$(TRIG):STARTING_UP" )
	field( INPA, "$(TRIG):ASUB_INVARIANT.VALB NPP NMS" )
	field( CALC, "A" )
	field( OOPT, "On Change" )
	field( EGU,  "ticks" )
	field( OUT, "$(EVR):CTRL.$(TYPE)$(N)D  PP MS" )
	field( FLNK, "$(TRIG):FW_TDLY_SCALE_CALC" )
}

record( calcout, "$(TRIG):FW_TDLY_SCALE_CALC" )
{
#field( TPRO, "$(TPRO=2)" )
	field( SDIS, "$(TRIG):STARTING_UP" )
	field( INPA, "$(TRIG):ASUB_INVARIANT.VALC NPP NMS" )
	field( CALC, "A" )
	field( OOPT, "On Change" )
	field( EGU,  "" )
	field( OUT, "$(EVR):CTRL.$(TYPE)$(N)C  PP MS" )
	field( FLNK, "$(TRIG):BW_TEC_CALC" )
}

record( calcout, "$(TRIG):BW_TEC_CALC" )
{
#field( TPRO, "$(TPRO=2)" )
	field( SDIS, "$(TRIG):STARTING_UP" )
	field( INPA, "$(TRIG):ASUB_INVARIANT.VALD NPP NMS" )
	field( CALC, "A" )
	field( OOPT, "On Change" )
	field( EGU,  "" )
#	field( OUT, "$(TRIG):TEC  PP NMS" )
}

# Trigger event code
record( longout, "$(TRIG):TEC" )
{
	field( DESC, "Trigger's Event code" )
	field( OUT,  "$(TRIG):EC_NAME.TSE" )
	field( FLNK, "$(TRIG):EC_NAME" )
	field( PINI, "YES" )
	field( TPRO, "$(TPRO=0)" )
	info( autosaveFields, "DESC VAL" )
}

# Trigger enable/disable record
record( bo, "$(TRIG):TCTL" )
{
	field( DESC, "Trigger Control" )
	field( DTYP, "Soft Channel" )
	field( OUT,  "$(EVR):CTRL.$(TCTL) PP" )
#	field( OUT,  "$(EVR):CTRL.$(TCTL) CA" )
	field( ZNAM, "Disabled" )
	field( ONAM, "Enabled" )
	field( OMSL, "supervisory" )
	field( VAL,  "$(CTL=0)" )
	field( PINI, "YES" )
	field( FLNK, "$(TRIG):FW_EC_SEQ" )
#	field( TPRO, "$(TPRO=0)" )
	info( autosaveFields, "DESC VAL ZNAM ONAM ZSV OSV" )
}

# Trigger polarity
record( bo, "$(TRIG):TPOL" )
{
	field( DESC, "Trigger Polarity" )
	field( DTYP, "Soft Channel" )
	field( OUT, "$(EVR):CTRL.$(TYPE)$(N)P PP" )
#	field( OUT, "$(EVR):CTRL.$(TYPE)$(N)P CA" )
	field( ZNAM, "Normal" )
	field( ONAM, "Inverted" )
	field( OMSL, "supervisory" )
	field( VAL, "$(POL=0)" )
	field( PINI, "YES" )
	info( autosaveFields, "DESC VAL ZNAM ONAM ZSV OSV" )
}

# Trigger width
record( ao, "$(TRIG):TWID" )
{
	field( DESC, "Trigger Width" )
	field( DTYP, "Raw Soft Channel" )
	field( OMSL, "supervisory" )
	field( LINR, "SLOPE" )
	field( EGU, "ns" )
	field( HOPR, "1000000000" )
	field( DRVH, "1000000000" )
	field( ESLO, "8.403361345" )
	field( VAL, "$(WID=100)" )
	field( MDEL, "-1" )
	field( FLNK, "$(TRIG):BW_DIS2" )
	field( PINI, "YES" )
	info( autosaveFields, "DESC EGU HHSV HIGH HIHI HSV LLSV LOLO LOW LSV PREC VAL" )
}

# Desired trigger delay as an offset relative
# to $(EVR):TREF, the trigger reference time
# Initialized to a negative number to force TDES to be back calculated
# from the pulse generator settings when no autosave value is found.
# Useful when transitioning to invariant timing.
record( ao, "$(TRIG):TDES" )
{
	field( DESC, "Desired Trig Delay" )
#	field( DTYP, "Raw Soft Channel" )
#	field( OMSL, "supervisory" )
#	field( LINR, "SLOPE" )
	field( EGU,  "ns" )
	field( PREC, "0" )
	field( HOPR, "$(DRVH=2.14748E09)" )
	field( LOPR, "$(DRVL=-2.14748E09)" )
	field( DRVH, "$(DRVH=2.14748E09)" )
	field( DRVL, "$(DRVL=-2.14748E09)" )
#	field( ESLO, "8.403361345" )
#	field( VAL, "$(DES=-1e9)" )
#	When to send VAL monitors
#	MDEL=0, on change
#	MDEL=-1, every process
	field( MDEL, "0" )
	field( PINI, "YES" )
	field( LSV,  "MINOR" )
	field( FLNK, "$(TRIG):TDLY_NS" )
	info( autosaveFields, "DESC EGU HHSV HIGH HIHI HSV LLSV LOLO LOW LSV VAL" )
	field( TPRO, "$(TPRO=0)" )
}

# Trigger event code
record( longout, "$(TRIG):EC_RBV" )
{
	field( DESC, "Trigger's Event code" )
	field( OMSL, "closed_loop" )
#	field( DOL,  "$(TRIG):LSUB_EVSEL NPP MS" )
	field( DOL,  "$(TRIG):LSUB_EVSEL CPP MS" )
#	field( FLNK, "$(TRIG):BW_EC_SEQ" )
	field( TPRO, "$(TPRO=0)" )
	info( autosaveFields, "DESC" )
}

# Disable the forward event code set sequence
# while updating from a backward fetch of the event code
# from an enabled ctrl record
# Note: Do not use any delays in this sequence or the
# record will still be active if new event code updates
# come through.  That is why the FW_EC_SEQ_ENAB is
# re-enabled in a separate PV.
record( seq, "$(TRIG):BW_EC_SEQ" )
{
	field( DOL1, "0" )
	field( LNK1, "$(TRIG):FW_EC_SEQ_ENAB PP NMS" )

#	field( DLY2, "0.5" )
	field( DOL2, "$(TRIG):EC_RBV NPP NMS" )
	field( TPRO, "$(TPRO=0)" )

	field( FLNK, "$(TRIG):FW_EC_SEQ_REENABLE PP NMS" )
	info( autosaveFields, "DESC" )
}

record( seq, "$(TRIG):FW_EC_SEQ_REENABLE" )
{
#	field( DLY1, "0.25" )
	field( DLY1, "0.5" )
#	field( DLY1, "0.01" )
	field( DOL1, "1" )
	field( LNK1, "$(TRIG):FW_EC_SEQ_ENAB NPP NMS" )
	info( autosaveFields, "DESC" )
#	field( TPRO, "$(TPRO=0)" )
}

# Tick count for the trigger
# Corresponds to the number of 8.4ns EVR time slots
# between the fiducial event code 1 and the current
# trigger event code.
# Value set by record $(TRIG):ASUB_LKUOFFSET
record( ai, "$(TRIG):TOFFSET" )
{
	field( TPRO, "$(TPRO=0)" )
	field( DESC, "Tick cnt for cur EC" )
	field( PINI, "NO" )
	field( EGU,  "ticks" )
	field( FLNK, "$(TRIG):TOFFSET_NS" )
	field( LOW,  "-1e-9" )
	field( LSV,  "MINOR" )
}

record( calc, "$(TRIG):TOFFSET_NS" )
{
#	field( TPRO, "$(TPRO=0)" )
	field( DESC, "Offset in ns for ec" )
	field( EGU,  "ns" )
	field( CALC, "A*B" )
	field( INPA, "$(TRIG):TOFFSET NPP MS" )
	field( INPB, "8.403361345" )
	field( FLNK, "$(TRIG):TDLY_NS" )
}

# This PV looks up the tick offset of
# the current event code for this trigger
# The event code is read by $(TRIG):LSUB_EVSEL and
# this record processes each time LSUB_EVSEL updates
record( aSub, "$(TRIG):ASUB_LKUOFFSET" )
{
	field( TPRO, "$(TPRO=0)" )
	field( DESC, "Offset lookup" )
	field( SCAN, "Passive" )
#	field( PINI, "YES" )
	field( INAM, "aSubEvOffsetInit" )
	field( SNAM, "aSubEvOffset" )
	field( INPA, "$(TRIG):LSUB_EVSEL.VAL CPP MS" )
	field( INPB, "$(ACTV=1)" )
	field( INPC, "$(EVR):EC:DELAYS CPP NMS" )
	field( INPD, "0" )
	field( FTA, "LONG" )
	field( FTB, "LONG" )
	field( FTC, "LONG" )
	field( FTD, "LONG" )
	field( NOC, "256" )
# Note: EFLG only affects monitors.  OUT links always get written
	field( EFLG, "ON CHANGE" )
	field( OUTA, "$(TRIG):TOFFSET.VAL PP MS" )
	field( FTVA, "LONG" )
#	field( FLNK, "$(TRIG):EC_RBV" )
}

# PV to read currently assigned event code
# Processes whenever any of the event controls
# posts a CA monitor event, which will happen
# if their event code is changed.
# Processes the LSUB_TRGSEL record via input Z to determine
# which control record's event code number to read
record( longSub, "$(TRIG):LSUB_EVSEL" )
{
	field( SDIS, "$(EVR):CTRL.IP$(N)E" )
	field( DISV, "0" )
	field( DESC, "Event Code Read" )
	field( SCAN, "Passive" )
	field( INAM, "lsubEvSelInit" )
	field( SNAM, "lsubEvSel" )
	field( INPA, "$(TRIG):EVENTCTRL.ENM CPP NMS" )
	field( INPB, "$(EVR):EVENT1CTRL.ENM CPP NMS" )
	field( INPC, "$(EVR):EVENT2CTRL.ENM CPP NMS" )
	field( INPD, "$(EVR):EVENT3CTRL.ENM CPP NMS" )
	field( INPE, "$(EVR):EVENT4CTRL.ENM CPP NMS" )
	field( INPF, "$(EVR):EVENT5CTRL.ENM CPP NMS" )
	field( INPG, "$(EVR):EVENT6CTRL.ENM CPP NMS" )
	field( INPH, "$(EVR):EVENT7CTRL.ENM CPP NMS" )
	field( INPI, "$(EVR):EVENT8CTRL.ENM CPP NMS" )
	field( INPJ, "$(EVR):EVENT9CTRL.ENM CPP NMS" )
	field( INPK, "$(EVR):EVENT10CTRL.ENM CPP NMS" )
	field( INPL, "$(EVR):EVENT11CTRL.ENM CPP NMS" )
	field( INPM, "$(EVR):EVENT12CTRL.ENM CPP NMS" )
	field( INPN, "$(EVR):EVENT13CTRL.ENM CPP NMS" )
	field( INPO, "$(EVR):EVENT14CTRL.ENM CPP NMS" )
	field( INPZ, "$(TRIG):LSUB_TRGSEL.VAL PP MS" )
#	field( FLNK, "$(TRIG):ASUB_LKUOFFSET" )
#	field( FLNK, "$(TRIG):ASUB_INVARIANT" )
	field( TPRO, "$(TPRO=0)" )
}

# This PV examines each of the 14 control records to find
# the first one which is enabled for this trigger's output
# It's value is 0 if the $(TRIG):EVENTCTRL is enabled,
# 1 if EVENT1CTRL is enabled, 2 for EVENT2CTRL, ...
# LSUB_TRGSEL is processed on demand by LSUB_EVSEL
record( longSub, "$(TRIG):LSUB_TRGSEL" )
{
#	field( TPRO, "$(TPRO=0)" )
	field( SDIS, "$(EVR):CTRL.IP$(N)E" )
	field( DISV, "0" )
	field( DESC, "Delay Selector" )
	field( SCAN, "Passive" )
#	field( PINI, "YES" )
	field( INAM, "lsubTrigSelInit" )
	field( SNAM, "lsubTrigSel" )
	field( INPA, "$(TRIG):EVENTCTRL.OUT$(N) NPP NMS" )
	field( INPB, "$(EVR):EVENT1CTRL.OUT$(N) NPP NMS" )
	field( INPC, "$(EVR):EVENT2CTRL.OUT$(N) NPP NMS" )
	field( INPD, "$(EVR):EVENT3CTRL.OUT$(N) NPP NMS" )
	field( INPE, "$(EVR):EVENT4CTRL.OUT$(N) NPP NMS" )
	field( INPF, "$(EVR):EVENT5CTRL.OUT$(N) NPP NMS" )
	field( INPG, "$(EVR):EVENT6CTRL.OUT$(N) NPP NMS" )
	field( INPH, "$(EVR):EVENT7CTRL.OUT$(N) NPP NMS" )
	field( INPI, "$(EVR):EVENT8CTRL.OUT$(N) NPP NMS" )
	field( INPJ, "$(EVR):EVENT9CTRL.OUT$(N) NPP NMS" )
	field( INPK, "$(EVR):EVENT10CTRL.OUT$(N) NPP NMS" )
	field( INPL, "$(EVR):EVENT11CTRL.OUT$(N) NPP NMS" )
	field( INPM, "$(EVR):EVENT12CTRL.OUT$(N) NPP NMS" )
	field( INPN, "$(EVR):EVENT13CTRL.OUT$(N) NPP NMS" )
	field( INPO, "$(EVR):EVENT14CTRL.OUT$(N) NPP NMS" )
#	field( FLNK, "$(TRIG):LSUB_EVSEL" )
}

# Forward trigger delay sequence enable calculation
# Input A is used for temporary disable of the FW_TDES sequence
# Processed on demand by FW_TDES_SEQ
record( calcout, "$(TRIG):FW_TDES_SEQ_ENAB_CALC" )
{
#	field( TPRO, "$(TPRO=0)" )
	field( INPA, "1" )
	field( INPB, "$(TRIG):LSUB_TRGSEL.SEVR NPP NMS" )
	field( INPC, "$(TRIG):TDES.SEVR NPP NMS" )
	field( INPD, "$(TRIG):TDLY NPP MS" )
	field( INPE, "$(TRIG):ASUB_LKUOFFSET.SEVR NPP NMS" )
	field( CALC, "A&&(B==0)&&(D>=0)&&(E==0)" )
#	field( CALC, "A&&(B==0)&&(C==0)&&(D>=0)&&(E==0)" )
#	field( OUT,  "$(TRIG):FW_TDES_SEQ_ENAB PP NMS" )
}

record( bo, "$(TRIG):FW_TDES_SEQ_ENAB" )
{
	field( TPRO, "$(TPRO=0)" )
	field( ZNAM, "Disabled" )
	field( ONAM, "Enabled" )
}

# Sequence for forward delay updates
# No delays in this record, see the re-enable
record( seq, "$(TRIG):FW_TDES_SEQ" )
{
	field( TPRO, "$(TPRO=0)" )
	field( SDIS, "$(TRIG):FW_TDES_SEQ_ENAB_CALC PP" )
	field( DISV, "0" )
	field( DESC, "Update delay seq" )

#   Disable the BW_TDES_SEQ while we do the FW_TDES_SEQ
	field( DOL1, "0" )
	field( LNK1, "$(TRIG):BW_TDES_SEQ_ENAB_CALC.A PP MS" )

#	field( DOL2, "$(TRIG):TDLY NPP MS" )
	field( DOL2, "1" )
	field( LNK2, "$(TRIG):FW_TDES_TICK_CALC.PROC PP NMS" )

	field( FLNK, "$(TRIG):BW_TDES_SEQ_REENABLE PP NMS" )
	info( autosaveFields, "DESC" )
}

# Reenable after a short delay
record( seq, "$(TRIG):BW_TDES_SEQ_REENABLE" )
{
#field( TPRO, "$(TPRO=1)" )
	field( DLY1, "0.25" )
	field( DOL1, "1" )
	field( LNK1, "$(TRIG):BW_TDES_SEQ_ENAB_CALC.A PP NMS" )
	info( autosaveFields, "DESC" )
}

# Backward trigger delay seqence enable calculation
# Input A is used for temporary disable of the BW_TDES sequence
# Processed on demand by BW_TDES_SEQ
record( calcout, "$(TRIG):BW_TDES_SEQ_ENAB_CALC" )
{
	field( INPA, "1" )
	field( INPB, "$(TRIG):LSUB_TRGSEL.SEVR NPP NMS" )
	field( CALC, "A && (B==0)" )
	field( OUT,  "$(TRIG):BW_TDES_SEQ_ENAB PP NMS" )
}

record( bo, "$(TRIG):BW_TDES_SEQ_ENAB" )
{
#field( TPRO, "$(TPRO=2)" )
	field( ZNAM, "Disabled" )
	field( ONAM, "Enabled" )
}

# Sequence for backward delay updates
# No delays in this record, see the re-enable
record( seq, "$(TRIG):BW_TDES_SEQ" )
{
#field( TPRO, "$(TPRO=1)" )
	field( SDIS, "$(TRIG):BW_TDES_SEQ_ENAB PP" )
	field( DISV, "0" )
	field( DESC, "Backward delay seq" )

#   Disable the FW_TDES_SEQ while we do the BW_TDES_SEQ
	field( DOL1, "0" )
	field( LNK1, "$(TRIG):FW_TDES_SEQ_ENAB_CALC.A NPP NMS" )

#	Update TDES from BW_TDES
#	field( DOL2, "$(TRIG):BW_TDES NPP MS" )
#	field( LNK2, "$(TRIG):TDES.VAL PP NMS" )

	field( FLNK, "$(TRIG):FW_TDES_SEQ_REENABLE PP NMS" )
	info( autosaveFields, "DESC" )
}

# Reenable after a short delay
record( seq, "$(TRIG):FW_TDES_SEQ_REENABLE" )
{
	field( DOL1, "1" )
	field( DLY1, "0.25" )
	field( LNK1, "$(TRIG):FW_TDES_SEQ_ENAB_CALC.A NPP NMS" )
	info( autosaveFields, "DESC" )
}

# This PV computes the Trigger Delay in ticks
record( calcout, "$(TRIG):TDLY" )
{
	field( TPRO, "$(TPRO=0)" )
	field( DESC, "Trigger EVR Delay" )
	field( INPA, "$(TRIG):TDLY_NS NPP MS" )
	field( INPB, "8.403361345" )
	field( CALC, "FLOOR((A/B)+0.5)" )
	field( OOPT, "On Change" )
	field( EGU,  "ticks" )
	field( LOW,  "-1e-9" )
	field( LSV,  "MINOR" )
	field( OUT,  "$(TRIG):TDLY_TICKS PP NMS" )
#	field( FLNK, "$(TRIG):FW_TDES_SEQ" )
}

# This record shows the pulse generator desired delay in ticks
# (May someday allow setting desired delay in ticks,
#  but for now is closed_loop to avoid DB process
#  chain errors.)
# It may not match the current pulse generator delay, as
# that can be set directly via CTRL.DG0D
#
# This PV may be eliminated soon, as I think the only
# safe way to inject a delay in ticks into this DB chain
# is the current solution, which is to write the desired
# delay directly to the CTRL.$(TYPE)$(N)D field.
#
# The other alternative would be to disable CA put operations
# to the entire CTRL record and make this PV the only one in the module that
# writes to the pulse generator delay.   Then this PV could
# be the other end of the FW vs BW seq chains.
# i.e.   TDES ---FW-->  TDLY_TICKS
#        TDES <--BW---  TDLY_TICKS
# instead of the current
# i.e.   TDES ---FW-->  CTRL.DG0D
#        TDES <--BW_TDES ---  CTRL.DG0D
record( ao, "$(TRIG):TDLY_TICKS"	)
{
	field( TPRO, "$(TPRO=0)" )
	field( DOL,  "$(TRIG):TDLY NPP MS" )
	field( OMSL, "closed_loop" )
	field( EGU,  "ticks" )
#	field( FLNK, "$(TRIG):FW_TDES_SEQ" )
}

record( calcout, "$(TRIG):FW_TDES_TICK_CALC"	)
{
	field( TPRO, "$(TPRO=0)" )
	field( INPA, "$(TRIG):TDLY NPP NMS" )
	field( INPB, "$(TRIG):LSUB_EVSEL.SEVR NPP NMS" )
	field( INPC, "$(EVR):CTRL.$(TYPE)$(N)C NPP NMS" )
	field( CALC, "(A>=0)&&(B==0)&&(C!=0)" )
	field( OOPT, "When Non-zero" )
	field( DOPT, "Use OCAL" )
	field( OCAL, "A/C" )
	field( OUT,  "$(EVR):CTRL.$(TYPE)$(N)D PP NMS" )
#	field( OUT,  "$(EVR):CTRL.$(TYPE)$(N)D CA NMS" )
	field( EGU,  "ticks" )
}

# This PV calculates the additional delay in ns
# after the event code before the trigger is generated
record( calc, "$(TRIG):TDLY_NS" )
{
	field( TPRO, "$(TPRO=0)" )
	field( DESC, "Trigger Delay" )
	field( CALC, "A+B-(C*D)" )
	field( INPA, "$(TRIG):TDES.VAL NPP MS" )
	field( INPB, "$(EVR):TREF CPP MS" )
	field( INPC, "$(TRIG):TOFFSET.VAL NPP MS" )
	field( INPD, "8.403361345" )
	field( EGU,  "ns" )
	field( HOPR, "1000000000" )
	field( PREC, "1" )
	field( FLNK, "$(TRIG):TDLY" )
	field( LOW,  "-1e-9" )
	field( LSV,  "MINOR" )
}

# Update TDES.LOW based on 0 tick delay
# Setting at 0.01 lower than calculated to avoid
# flagging 0 delays on EC 140 due to rounding errors
record( calcout, "$(TRIG):TDES_CALC_LOW" )
{
#	field( TPRO, "$(TPRO=0)" )
	field( DESC, "TDES low limit calc" )
	field( CALC, "A*B-C-0.01" )
	field( INPA, "$(TRIG):TOFFSET.VAL CPP NMS" )
	field( INPB, "8.403361345" )
	field( INPC, "$(EVR):TREF CPP MS" )
	field( EGU,  "ns" )
	field( PREC, "2" )
	field( OUT,  "$(TRIG):TDES.LOW NPP NMS" )
	field( FLNK,  "$(TRIG):TDES_CALC_LOPR PP NMS" )
}

record( ao, "$(TRIG):TDES_CALC_LOPR" )
{
#	field( TPRO, "$(TPRO=0)" )
	field( DESC, "TDES low operator calc" )
	field( OMSL, "closed_loop" )
	field( DOL,  "$(TRIG):TDES_CALC_LOW NPP MS" )
	field( EGU,  "ns" )
	field( PREC, "2" )
	field( OUT,  "$(TRIG):TDES.LOPR NPP NMS" )
}

# Grab the delay tick count for easy edm viewing w/ EGU of ticks
record( calcout, "$(TRIG):BW_TDLY" )
{
#	field( TPRO, "$(TPRO=0)" )
	field( DESC, "Tick count from delay gen" )
	field( INPA, "$(EVR):CTRL.$(TYPE)$(N)D CPP NMS" )
	field( INPB, "$(EVR):CTRL.$(TYPE)$(N)C CPP NMS" )
	field( CALC, "A*B" )
# 	field( OOPT, "On Change" )
	field( OUT,  "$(TRIG):BW_TDLY_TICKS PP MS" )
# Try this
#	field( OUT,  "$(TRIG):BW_TDLY_NS.A PP MS" )
	field( EGU,  "ticks" )
}

# Process only on a change in BW_TDLY
record( ao, "$(TRIG):BW_TDLY_TICKS" )
{
#field( TPRO, "$(TPRO=2)" )
	field( DESC, "Tick count from delay gen" )
	field( EGU,  "ticks" )
	field( PINI, "YES" )
	field( FLNK, "$(TRIG):BW_TDLY_NS" )
}

# Compute time delay in ns after the event code
record( calc, "$(TRIG):BW_TDLY_NS" )
{
	field( TPRO, "$(TPRO=0)" )
	field( DESC, "Backward delay after EC" )
	field( SCAN, "Passive" )
	field( CALC, "A*B" )
	field( INPA, "$(TRIG):BW_TDLY_TICKS NPP MS" )
	field( INPB, "8.403361345" )
	field( EGU,  "ns" )
	field( PREC, "2" )
	field( FLNK, "$(TRIG):BW_TDES" )
}

# Compute desired delay relative to TREF (ns)
record( calcout, "$(TRIG):BW_TDES" )
{
#	field( TPRO, "$(TPRO=0)" )
	field( DESC, "Backward TDES calc" )
	field( SCAN, "Passive" )
#	field( SDIS, "$(TRIG):BW_TDES_SEQ_ENAB PP" )
#	field( DISV, "0" )
	field( CALC, "(A+B)*C-D" )
# which?
	field( INPA, "$(TRIG):TOFFSET.VAL CPP MS" )
#	field( INPA, "$(TRIG):ASUB_LKUOFFSET.VALA PP MS" )
	field( INPB, "$(TRIG):BW_TDLY NPP MS" )
	field( INPC, "8.403361345" )
	field( INPD, "$(EVR):TREF NPP MS" )
	field( EGU,  "ns" )
	field( PREC, "2" )
}

record( seq, "$(TRIG):PROP_SEQ2" )
{
#	field( TPRO, "$(TPRO=0)" )
	field( PINI, "YES" )
	field( DLY1, "15" )
	field( DOL1, "1" )
	field( LNK1, "$(TRIG):FW_SEQ2.DLY1" )
}

record( fanout, "$(TRIG):TINI" )
{
#	field( TPRO, "$(TPRO=2)" )
# These fanout links shouldn't be needed.  Just set their PINI=YES
	field( DESC, "Trigger Init" )
	field( PINI, "YES" )
#	field( LNK1, "$(TRIG):TDES PP" )
	field( LNK2, "$(TRIG):TWID PP" )
	field( LNK3, "$(TRIG):TPOL PP" )
	field( LNK4, "$(TRIG):TCTL PP" )
}

record( seq, "$(TRIG):TPOL_ITNSEQ" )
{
	field( DLY1, "0" )
	field( DOL1, "0" )
	field( LNK1, "$(TRIG):TPOL_ITN.DISV" )

	field( DLY2, ".5" )
	field( DOL2, "1" )
	field( LNK2, "$(TRIG):TPOL_ITN.DISV" )
}

record( bo, "$(TRIG):TPOL_ITN" )
{
	field( SCAN, "Passive" )
	field( DTYP, "Soft Channel" )
	field( OMSL, "closed_loop" )
	field( DOL,  "$(EVR):CTRL.$(TYPE)$(N)P CPP NMS" )
	field( OUT,  "$(TRIG):TPOL.VAL PP" )
	field( ZNAM, "Normal" )
	field( ONAM, "Inverted" )
	field( FLNK, "$(TRIG):TPOL_ITNSEQ" )
}

record( seq, "$(TRIG):TCTL_ITNSEQ" )
{
	field( DLY1, "0" )
	field( DOL1, "0" )
	field( LNK1, "$(TRIG):TCTL_ITN.DISV" )

	field( DLY2, ".5" )
	field( DOL2, "1" )
	field( LNK2, "$(TRIG):TCTL_ITN.DISV" )
}

record( bo, "$(TRIG):TCTL_ITN" )
{
#	field( TPRO, "$(TPRO=0)" )
	field( SCAN, "Passive" )
	field( DTYP, "Soft Channel" )
	field( OMSL, "closed_loop" )
	field( DOL,  "$(EVR):CTRL.$(TCTL) CPP NMS" )
	field( OUT,  "$(TRIG):TCTL.VAL PP" )
	field( ZNAM, "Disabled" )
	field( ONAM, "Enabled" )
	field( FLNK, "$(TRIG):TCTL_ITNSEQ" )
}

record( ao, "$(TRIG):BW_DIS2" )
{
	field( FLNK, "$(TRIG):FW_FOUT2" )
	field( OUT,  "$(TRIG):BW_SW2.VAL PP" )
	field( DOL,  "1" )
	field( OMSL, "closed_loop" )
	field( SDIS, "$(TRIG):FW_SW2.VAL" )
}

record( ai, "$(TRIG):FW_SW2" )
{
}

record( seq, "$(TRIG):BW_SEQ2" )
{
#	field( TPRO, "$(TPRO=0)" )
	field( DLY1, "1." )
	field( DOL1, "0" )
	field( LNK1, "$(TRIG):FW_SW2.VAL PP" )
}

record( fanout, "$(TRIG):FW_FOUT2" )
{
#	field( TPRO, "$(TPRO=0)" )
	field( SDIS, "$(TRIG):FW_SW2.VAL" )
	field( FLNK, "$(TRIG):FW_SEQ2" )
	field( LNK1, "$(TRIG):TWID2" )
}

record( seq, "$(TRIG):FW_SEQ2" )
{
#	field( TPRO, "$(TPRO=0)" )
	field( DLY1, "15" )
	field( DOL1, "0" )
	field( LNK1, "$(TRIG):BW_SW2.VAL PP" )
}

record( fanout, "$(TRIG):BW_FOUT2" )
{
#	field( TPRO, "$(TPRO=0)" )
	field( FLNK, "$(TRIG):BW_SEQ2" )
	field( LNK1, "$(TRIG):BW_TWID" )
}

record( ai, "$(TRIG):BW_SW2" )
{
}

record( ao, "$(TRIG):BW_TWID" )
{
	field( SDIS, "$(TRIG):BW_SW2.VAL" )
	field( OUT, "$(TRIG):TWID.VAL PP" )
	field( DOL, "$(TRIG):BW_TWIDCALC.VAL" )
	field( OMSL, "closed_loop" )
}

record( ao, "$(TRIG):FW_DIS2" )
{
	field( FLNK, "$(TRIG):BW_FOUT2" )
	field( OUT, "$(TRIG):FW_SW2.VAL PP" )
	field( DOL, "1" )
	field( OMSL, "closed_loop" )
	field( SDIS, "$(TRIG):BW_SW2.VAL" )
}

record( calcout, "$(TRIG):TWID2" )
{
	field( DESC, "Trigger Width" )
	field( INPA, "$(TRIG):TWID.VAL" )
	field( INPB, "$(EVR):CTRL.$(TYPE)$(N)C NPP NMS" )
	field( INPC, "8.403361345" )
	field( CALC, "A/B/C" )
	field( OUT,  "$(EVR):CTRL.$(TYPE)$(N)W PP NMS" )
#	field( OUT,  "$(EVR):CTRL.$(TYPE)$(N)W CA NMS" )
	field( EGU, "ns" )
	field( PREC, "1" )
	field( VAL, "$(WID=100)" )
	field( MDEL, "-1" )
# No need to disable TWID2
#	field( SDIS, "$(TRIG):FW_SW2.VAL" )
}

# Grab the width tick count for easy edm viewing w/ EGU of ticks
record( calc, "$(TRIG):BW_TWID_TICKS" )
{
	field( DESC, "Width from delay gen" )
	field( INPA,  "$(EVR):CTRL.$(TYPE)$(N)W CPP NMS" )
	field( INPB,  "$(EVR):CTRL.$(TYPE)$(N)C CPP NMS" )
	field( CALC, "A*B" )
	field( EGU,  "ticks" )
	field( FLNK, "$(TRIG):BW_TWIDCALC" )
}

record( calc, "$(TRIG):BW_TWIDCALC" )
{
	field( INPA, "$(TRIG):BW_TWID_TICKS NPP MS" )
	field( INPB, "8.403361345" )
	field( CALC, "A*B" )
	field( EGU,  "ns" )
	field( PREC, "1" )
	field( FLNK, "$(TRIG):FW_DIS2" )
}

# Records for fetching the trigger's event code, count, rate, and event name.
record( longSub, "$(TRIG):CNT" )
{
	field( DESC, "Trigger Count" )
	field( SNAM, "evrTimeEvent" )
	field( BRSV, "INVALID" )
	field( INPA, "$(TRIG):LSUB_EVSEL NPP MS" )
	field( SCAN, ".1 second" )
}

record( sub, "$(TRIG):RATE" )
{
	field( DESC, "Trigger Rate" )
	field( SNAM, "evrTimeRate" )
	field( BRSV, "INVALID" )
	field( SCAN, "Event" )
	field( EVNT, "121" )
	field( PRIO, "MEDIUM" )
	field( INPE, "$(TRIG):LSUB_EVSEL NPP MS" )
	field( EGU,  "Hz" )
	field( PREC, "1" )
	field( LOW,  "0" )
	field( LSV,  "MINOR" )
}

# This record returns a copy of the event code name
# for the event code specified by it's EVNT field.
# Update that field dynamically to fetch the name
# for a different event code.
record( stringin, "$(TRIG):EC_NAME" )
{
	field( DESC,  "Get event code name" )
	field( DTYP,  "MRF Event Receiver" )
	field( INP,   "#C$(CARD) S0 @" )
	field( TSE,   "0" )
	field( FLNK,  "$(TRIG):FW_EC_SEQ" )
}

record( bo, "$(TRIG):FW_EC_SEQ_ENAB" )
{
	field( DOL,  "1" )
	field( ZNAM, "Disabled" )
	field( ONAM, "Enabled" )
}

# Disable BW_EC_SEQ during startup
# and during FW_EC_SEQ to avoid stepping on TEC
record( bo, "$(TRIG):BW_EC_SEQ_DISABLE" )
{
	field( TPRO, "$(TPRO=0)" )
	field( DOL,	 "1" )
	field( ZNAM, "Enabled" )
	field( ONAM, "Disabled" )
	field( OUT,  "$(TRIG):BW_EC_SEQ.DISA" )
	field( HIGH, "1.0" )
	field( PINI, "YES" )
}

# The foward event code sequence is now an aSub
# record, which copies INPA to OUTA, INPB to OUTB, ...
# It's configured to write the current trigger event code
# to the trigger's dedicated erevent EVENTCTRL event code field.
# It also enables that EVENTCTRL record and turns off any
# other EVENT[1..14]CTRL records that are enabled.
record( aSub, "$(TRIG):FW_EC_SEQ" )
{
	field( TPRO, "$(TPRO=0)" )
	field( SDIS, "$(TRIG):FW_EC_SEQ_ENAB" )
	field( DISV, "0" )
	field( DESC, "Output Selector" )
	field( SCAN, "Passive" )
	field( PINI, "NO" )
	field( FLNK, "$(TRIG):BW_EC_SEQ_DISABLE" )
# NOTE: EFLG ON CHANGE suppress CA monitor events, but
# OUT* links get processed on each successful process.
#	field( EFLG, "ON CHANGE" )
	field( EFLG, "ON CHANGE" )
	field( INAM, "asubCopyInToOutInit" )
	field( SNAM, "asubCopyInToOut" )

	field( FTA,  "ULONG" )
	field( FTVA, "ULONG" )
	field( INPA, "$(TRIG):TEC NPP NMS" )
	field( OUTA, "$(TRIG):EVENTCTRL.ENM NPP NMS" )

	field( FTB,  "ULONG" )
	field( FTVB, "ULONG" )
	field( INPB, "1" )
	field( OUTB, "$(TRIG):EVENTCTRL.ENAB NPP NMS" )

	field( FTC,  "ULONG" )
	field( FTVC, "ULONG" )
	field( INPC, "1" )
	field( OUTC, "$(TRIG):EVENTCTRL.OUT$(N)  PP  NMS" )

    # The inputs for these are all zero
	# Use DB_LINK instead of CA_LINK so we don't post these to scanOnce
	field( OUTD, "$(EVR):EVENT1CTRL.OUT$(N)  NPP NMS" )
	field( OUTE, "$(EVR):EVENT2CTRL.OUT$(N)  NPP NMS" )
	field( OUTF, "$(EVR):EVENT3CTRL.OUT$(N)  NPP NMS" )
	field( OUTG, "$(EVR):EVENT4CTRL.OUT$(N)  NPP NMS" )
	field( OUTH, "$(EVR):EVENT5CTRL.OUT$(N)  NPP NMS" )
	field( OUTI, "$(EVR):EVENT6CTRL.OUT$(N)  NPP NMS" )
	field( OUTJ, "$(EVR):EVENT7CTRL.OUT$(N)  NPP NMS" )
	field( OUTK, "$(EVR):EVENT8CTRL.OUT$(N)  NPP NMS" )
	field( OUTL, "$(EVR):EVENT9CTRL.OUT$(N)  NPP NMS" )
	field( OUTM, "$(EVR):EVENT10CTRL.OUT$(N) NPP NMS" )
	field( OUTN, "$(EVR):EVENT11CTRL.OUT$(N) NPP NMS" )
	field( OUTO, "$(EVR):EVENT12CTRL.OUT$(N) NPP NMS" )
	field( OUTP, "$(EVR):EVENT13CTRL.OUT$(N) NPP NMS" )
	field( OUTQ, "$(EVR):EVENT14CTRL.OUT$(N) NPP NMS" )

	field( INPD, "0" ) field( FTD, "ULONG" ) field( FTVD, "ULONG" )
	field( INPE, "0" ) field( FTE, "ULONG" ) field( FTVE, "ULONG" )
	field( INPF, "0" ) field( FTF, "ULONG" ) field( FTVF, "ULONG" )
	field( INPG, "0" ) field( FTG, "ULONG" ) field( FTVG, "ULONG" )
	field( INPH, "0" ) field( FTH, "ULONG" ) field( FTVH, "ULONG" )
	field( INPI, "0" ) field( FTI, "ULONG" ) field( FTVI, "ULONG" )
	field( INPJ, "0" ) field( FTJ, "ULONG" ) field( FTVJ, "ULONG" )
	field( INPK, "0" ) field( FTK, "ULONG" ) field( FTVK, "ULONG" )
	field( INPL, "0" ) field( FTL, "ULONG" ) field( FTVL, "ULONG" )
	field( INPM, "0" ) field( FTM, "ULONG" ) field( FTVM, "ULONG" )
	field( INPN, "0" ) field( FTN, "ULONG" ) field( FTVN, "ULONG" )
	field( INPO, "0" ) field( FTO, "ULONG" ) field( FTVO, "ULONG" )
	field( INPP, "0" ) field( FTP, "ULONG" ) field( FTVP, "ULONG" )
	field( INPQ, "0" ) field( FTQ, "ULONG" ) field( FTVQ, "ULONG" )
	field( INPR, "0" ) field( FTR, "ULONG" ) field( FTVR, "ULONG" )
	field( INPS, "0" ) field( FTS, "ULONG" ) field( FTVS, "ULONG" )
	field( INPT, "0" ) field( FTT, "ULONG" ) field( FTVT, "ULONG" )
	field( INPU, "0" ) field( FTU, "ULONG" ) field( FTVU, "ULONG" )
}

